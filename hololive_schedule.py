# Required additional packages:
# 1. bs4 (html analyse)
# 2. requests (get webpage)


import re
import os
import time
import datetime


# Install BeautifulSoup, lxml and requests with pip3 (If they are not installed)
try:
    from bs4 import BeautifulSoup
    import lxml
    import requests as req
except:
    os.system('pip3 install bs4 lxml requests')
    from bs4 import BeautifulSoup
    import requests as req


start = time.time()


# English name of the members
en_name = {
    '„Éõ„É≠„É©„Ç§„Éñ': 'Hololive',
    '„Å®„Åç„ÅÆ„Åù„Çâ': 'Tokino Sora',
    '„É≠„ÉúÂ≠ê„Åï„Çì': 'Roboco',
    '„Åï„Åè„Çâ„Åø„Åì': 'Sakura Miko',
    'ÊòüË°ó„Åô„ÅÑ„Åõ„ÅÑ': 'Hoshimachi Suisei',
    'Â§úÁ©∫„É°„É´': 'Yozora Mel',
    'Â§èËâ≤„Åæ„Å§„Çä': 'Natsuiro Matsuri',
    'Ëµ§‰∫ï„ÅØ„ÅÇ„Å®': 'Akai Haato',
    '„Ç¢„Ç≠„É≠„Çº': 'Aki Rosenthal',
    'ÁôΩ‰∏ä„Éï„Éñ„Ç≠': 'Shirakami Fubuki',
    'Êπä„ÅÇ„Åè„ÅÇ': 'Minato Aqua',
    'Á¥´Âí≤„Ç∑„Ç™„É≥': 'Murasaki Shion',
    'ÁôæÈ¨º„ÅÇ„ÇÑ„ÇÅ': 'Nakiri Ayame',
    'ÁôíÊúà„Å°„Çá„Åì': 'Yuzuki Choco',
    'Â§ßÁ©∫„Çπ„Éê„É´': 'Oozora Subaru',
    'Â§ßÁ•û„Éü„Ç™': 'Ookami Mio',
    'Áå´Âèà„Åä„Åã„ÇÜ': 'Nekomata Okayu',
    'ÊàåÁ•û„Åì„Çç„Å≠': 'Inugami Korone',
    'ÂÖéÁî∞„Å∫„Åì„Çâ': 'Usada Pekora',
    'ÊΩ§ÁæΩ„Çã„Åó„ÅÇ': 'Uruha Rushia',
    '‰∏çÁü•ÁÅ´„Éï„É¨„Ç¢': 'Shiranui Flare',
    'ÁôΩÈäÄ„Éé„Ç®„É´': 'Shirogane Noel',
    'ÂÆùÈêò„Éû„É™„É≥': 'Houshou Marine',
    'Â§©Èü≥„Åã„Å™„Åü': 'Amane Kanata',
    'Ê°êÁîü„Ç≥„Ç≥': 'Kiryu Coco',
    'ËßíÂ∑ª„Çè„Åü„ÇÅ': 'Tsunomaki Watame',
    'Â∏∏Èóá„Éà„ÉØ': 'Tokoyami Towa',
    'Âß´Ê£Æ„É´„Éº„Éä': 'Himemori Luna',
    'AZKi': 'AZKi',
    'Risu': 'Ayunda Risu',
    'Moona': 'Moona Hoshinova',
    'Iofi': 'Airani Iofifteen',
    'Â§ïÂàª„É≠„Éô„É´': 'Yukoku Roberu',
    'Â•èÊâã„Ç§„ÉÖ„É´': 'Kanade Izuru',
    'Êúà‰∏ã„Ç´„Ç™„É´': 'Tsukishita Kaoru',
    'Ëä±Âí≤„Åø„ÇÑ„Å≥': 'Hanasaki Miyabi',
    'Èè°Ë¶ã„Ç≠„É©': 'Kagami Kira',
    '„Ç¢„É´„É©„É≥„Éá„Ç£„Çπ': 'Arurandeisu',
    'ÂæãÂèØ': 'Rikka',
    '„Ç¢„Çπ„ÉÜ„É´„Éª„É¨„ÉÄ': 'Astel Leda',
    'Â≤∏Â†ÇÂ§©Áúü': 'Kishido Temma',
    'ÂΩ±Â±±„Ç∑„Ç®„É≥': 'Kageyama Shien',
    'ËçíÂí¨„Ç™„Ç¶„Ç¨': 'Aragami Oga',
    '„Éõ„É≠„Çπ„Çø„Éº„Ç∫': 'Holostars',
    'Èõ™Ëä±„É©„Éü„Ç£': 'Yukihana Lamy',
    'ÁçÖÁôΩ„Åº„Åü„Çì': 'Shishiro Botan',
    'Â∞æ‰∏∏„Éù„É´„Ç´': 'Omaru Polka',
    'Ê°ÉÈà¥„Å≠„Å≠': 'Momosuzu Nene',
    'È≠î‰πÉ„Ç¢„É≠„Ç®': 'Mano Aloe',
    'Ina': "Ninomae Ina'nis",
    'Gura': 'Gawr Gura',
    'Amelia': 'Watson Amelia',
    'Calli': 'Mori Calliope',
    'Kiara': 'Takanashi Kiara'
}


# Emoji of the members
emoji = {
    '„Å®„Åç„ÅÆ„Åù„Çâ': '',
    '„É≠„ÉúÂ≠ê„Åï„Çì': 'ü§ñ',
    '„Åï„Åè„Çâ„Åø„Åì': 'üíÆ',
    'ÊòüË°ó„Åô„ÅÑ„Åõ„ÅÑ': '‚òÑÔ∏è',
    'Â§úÁ©∫„É°„É´': 'üåü',
    'Â§èËâ≤„Åæ„Å§„Çä': 'üèÆ',
    'Ëµ§‰∫ï„ÅØ„ÅÇ„Å®': '‚ù§Ô∏è',
    '„Ç¢„Ç≠„É≠„Çº': 'üçé',
    'ÁôΩ‰∏ä„Éï„Éñ„Ç≠': 'üåΩ',
    'Êπä„ÅÇ„Åè„ÅÇ': '‚öìÔ∏è',
    'Á¥´Âí≤„Ç∑„Ç™„É≥': 'üåô',
    'ÁôæÈ¨º„ÅÇ„ÇÑ„ÇÅ': 'üòà',
    'ÁôíÊúà„Å°„Çá„Åì': 'üç´üíã',
    'Â§ßÁ©∫„Çπ„Éê„É´': 'üöë',
    'Â§ßÁ•û„Éü„Ç™': 'üå≤',
    'Áå´Âèà„Åä„Åã„ÇÜ': 'üçô',
    'ÊàåÁ•û„Åì„Çç„Å≠': 'ü•ê',
    'ÂÖéÁî∞„Å∫„Åì„Çâ': 'üëØ',
    'ÊΩ§ÁæΩ„Çã„Åó„ÅÇ': 'ü¶ã',
    '‰∏çÁü•ÁÅ´„Éï„É¨„Ç¢': 'üî•',
    'ÁôΩÈäÄ„Éé„Ç®„É´': '‚öî',
    'ÂÆùÈêò„Éû„É™„É≥': 'üè¥‚Äç‚ò†Ô∏è',
    'Â§©Èü≥„Åã„Å™„Åü': 'üí´',
    'Ê°êÁîü„Ç≥„Ç≥': 'üêâ',
    'ËßíÂ∑ª„Çè„Åü„ÇÅ': 'üêè',
    'Â∏∏Èóá„Éà„ÉØ': 'üëæ',
    'Âß´Ê£Æ„É´„Éº„Éä': 'üç¨',
    'AZKi': 'üé§',
    'Risu': 'üêø',
    'Moona': 'üîÆ',
    'Iofi': 'üé®',
    'Â§ïÂàª„É≠„Éô„É´': 'üç∑',
    'Â•èÊâã„Ç§„ÉÖ„É´': 'üé∏',
    'Êúà‰∏ã„Ç´„Ç™„É´': 'üíÖ',
    'Ëä±Âí≤„Åø„ÇÑ„Å≥': 'üå∫',
    'Èè°Ë¶ã„Ç≠„É©': 'üíô',
    '„Ç¢„É´„É©„É≥„Éá„Ç£„Çπ': 'üçï',
    'ÂæãÂèØ': '‚öô',
    '„Ç¢„Çπ„ÉÜ„É´„Éª„É¨„ÉÄ': 'üé≠',
    'Â≤∏Â†ÇÂ§©Áúü': 'ü¶îüí®',
    'ÂΩ±Â±±„Ç∑„Ç®„É≥': 'üü£',
    'ËçíÂí¨„Ç™„Ç¶„Ç¨': 'üêÉ',
    '„Éõ„É≠„Çπ„Çø„Éº„Ç∫': '',
    'Èõ™Ëä±„É©„Éü„Ç£': '‚òÉÔ∏è',
    'ÁçÖÁôΩ„Åº„Åü„Çì': '‚ôå',
    'Â∞æ‰∏∏„Éù„É´„Ç´': 'üé™',
    'Ê°ÉÈà¥„Å≠„Å≠': 'ü•ü',
    'È≠î‰πÉ„Ç¢„É≠„Ç®': 'üëÖ',
    'Ina': 'üêô',
    'Gura': 'üî±',
    'Amelia': 'üîé',
    'Calli': 'üíÄ',
    'Kiara': 'üêî'
}


# Designed UA header for HTTP-GET request
headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36",
}


# Get cookie from domain schedule.hololive.tv
cookie_local = {}
resp = req.get("https://schedule.hololive.tv/lives/all", headers=headers)
cookie_local = resp.cookies
# Set the timezone as UTC in cookie to get schedule in UTC timezone
cookie_local.set("timezone", "UTC", domain="schedule.hololive.tv")


# Get HTML response of the schedule webpage
def get_html():
    resp = req.get("https://schedule.hololive.tv/lives/all",
                   cookies=cookie_local)
    return resp


# Get the nodes contain schedule info
# (The real live schedule is a div tag which class is 'tab-content')
def get_raw_schedule(html):
    soup = BeautifulSoup(html.text, "lxml")
    return soup.find_all(class_="tab-content")


# Traverse all tag nodes and classify them as tags contain date,
# time, VTuber's name and liveroom link, using class-id
def tag_classify(tag):
    if(tag.has_attr("class")):
        class_list = tag['class']
        # Tags contain date strings always with a class-id 'holodule navbar-text'
        if('holodule' in class_list
                and 'navbar-text' in class_list):
            return "date"
        # Tags contain time strings always with a class-id contains 'datetime'
        elif('datetime' in class_list):
            return "time"
        # Tags contain VTuber name always with a class-id contains 'text-right name'
        elif('col' in class_list and 'text-right' in class_list and 'name' in class_list):
            return "name"
        # Tags contain liveroom link always with a class-id contains 'thumbnail'
        elif('thumbnail' in class_list):
            return "link"
        else:
            return "others"
    else:
        return "others"


# Confirm if the VTuber is streaming now
# (The VTubers who are streaming will have a red border around the liveroom info card on the schedule webpage)
def is_streaming(tag):
    if(tag.has_attr("style")):
        style_list = tag['style']
        if('border: 3px red solid' in style_list):
            return True
        else:
            return False
    else:
        return False


# Format the strings from tag nodes
def format_string(string):
    return string.replace("\n", "").replace("\t", "").replace("\r", "").replace("None", "").replace(" ", "")


# Confirm if a VTuber's live is not started
# (The liveroom about to start will have strings contains 'scheduledStartTime' in their webpages)
def is_upcoming(tag):
    start = time.time()
    resp = req.get(tag['href'])
    upcoming_flag = re.search("scheduledStartTime", resp.text)
    if(upcoming_flag is not None):
        end = time.time()
        print("module is_upcoming: ")
        print(end-start)
        return True
    else:
        end = time.time()
        print("module is_upcoming: ")
        print(end-start)
        return False


# Auto detect timezone and convert UTC time (on the webpage) to user's loacl time
def utc_2_localtime(utc):
    utc_t = datetime.datetime.strptime(utc, "%m/%d %H:%M")
    local_timestamp = time.time()
    local_time = datetime.datetime.fromtimestamp(local_timestamp)
    utc_time = datetime.datetime.utcfromtimestamp(local_timestamp)
    offset = local_time - utc_time
    local = utc_t + offset
    return (datetime.datetime.strftime(local, "%m/%d %H:%M"))


# Get current time
def get_current_time():
    timestamp = time.time()
    local = datetime.datetime.fromtimestamp(timestamp)
    return (datetime.datetime.strftime(local, "%m/%d %H:%M"))


# Get the tag nodes contain schedule info
raw_schedule = get_raw_schedule(get_html())
# Date status (changed when analyse new date)
date = "date_dummy_string"
schedule = []                                       # Blank schedule list
live = {}                                           # Blank liveroom dictionary
timezone = time.strftime("%z", time.localtime())    # User's timezone


# Analyse tag nodes
for tag in raw_schedule[0].find_all():
    # Tags contain date string detected (like '06/30(Êó•)'), update date value
    if(tag_classify(tag) == "date"):
        date = format_string(tag.string)[0:5]       # Drop week info
    # Tags contain time string detected (like '14:00'),
    # combine date and time as a key in the dictionary
    elif(tag_classify(tag) == "time"):
        for time_string in tag.strings:
            if(time_string.replace("\n", "").replace("\t", "").replace("\r", "").replace("None", "").replace(" ", "") is not ""):
                live['time'] = utc_2_localtime(
                    date+" "+format_string(time_string))
                # Streaming time is further than current time,
                # which means the stream is not beginning
                if(live['time'] > get_current_time()):
                    live['status'] = 'upcoming'
    # Tags contain VTuber's name string detected (like 'Risu'),
    # insert the name as a key in the dictionary
    elif(tag_classify(tag) == "name"):
        live['host'] = format_string(tag.string)
    # Tags contain liveroom link detected,
    # get the status of the liveroom (Stream over, Streaming now or Stream will start)
    # and insert different key in the dictionary
    elif(tag_classify(tag) == "link"):
        live['link'] = tag['href']
        if(is_streaming(tag) is True):
            live['status'] = 'streaming'
        else:
            live['status'] = 'over'
    # If all keys of a dictionary is inserted, append it into the schedule list
    if(len(live) == 4):
        schedule.append(live)
        live = {}   # Clear the dictionary for new info


end = time.time()
time_taken = str(end - start)


print("‚ñ∂Ô∏è")
print("---")
print("Click to jump to hololive offical schedule website... | href=https://schedule.hololive.tv")
print("---")
print("Updated in " + time_taken + " seconds")
print("---")
print("Streaming now (Click to jump to the chatroom in your web browser)")
for stream_live in schedule:
    if(stream_live['status'] == 'streaming'):
        print("üî¥ "+en_name.get(str(stream_live['host']), "")+" "
                +emoji.get(str(stream_live['host']), "")
            + " | href=" + stream_live['link'])
print("---")
for upcoming_live in schedule:
    if(upcoming_live['status'] == 'upcoming'):
        print(upcoming_live['time']+" "
                +en_name.get(str(upcoming_live['host']), "")+" "
                +emoji.get(str(upcoming_live['host']), "")
                +" | href="+upcoming_live['link'])
